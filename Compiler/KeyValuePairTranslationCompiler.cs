using System.Linq;
using System.Text.Encodings.Web;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Text.Unicode;
using FuzzySharp;
using NermNermNerm.Stardew.LocalizeFromSource;

namespace LocalizeFromSource
{
    /// <summary>
    ///   This is the base class for translation compilers that store their translations in
    ///   tables where there's a key that's used to look up the translations in source and
    ///   target languages.
    /// </summary>
    public abstract class KeyValuePairTranslationCompiler
        : TranslationCompiler
    {
        private readonly CombinedConfig config;

        protected KeyValuePairTranslationCompiler(CombinedConfig config)
        {
            this.config = config;
        }

        private record SourceChange(string? key, string? oldString, string? newString);

        protected const string DoNotEditComment = "// Do not edit this file - it is generated during compilation";
        protected const string EditsFileNoteToTranslatorComment = "// Translators - only edit 'newTarget' values.  The build for this project will apply your changes to the language.json file";
        protected const string TemplateComment =
@"// Translators - This file aims to help you by providing links to the source code while you're translating.
// It probably will really only be of help if you can build the project or write or get some json to convert
// this json into a regular translation json.  If you can do that, then edit the 'newTarget' field to the
// correct translation and rename this file so that it matches your language, e.g. if you are translating to
// Spanish, copy this to 'es.edits.json'.  When you build, it will create 'es.json' out of your 'newTarget' changes.";

        protected abstract IEnumerable<string> GetActiveLocales();
        protected abstract string GetPathToEditsFile(string locale);
        protected abstract string GetPathToNewLanguageTemplate();
        protected abstract Dictionary<string, string> ReadTranslationTable(string? locale);
        protected abstract void SaveTranslationTable(string? locale, Dictionary<string, string> newTranslations, Func<string, string> keyToSortOrder);

        // We provide default implementations for saving and loading the edits files and new language template
        //  because they aren't going to actually be consumed by the program we're localizing.  They're targeted
        //  at translators and developers.  Implementations are still required to tell us where to put them, though.

        protected virtual void SaveEditsFile(string locale, Dictionary<string, TranslationEdit> edits, Func<string, string> keyToSortOrder)
        {
            string path = GetPathToEditsFile(locale);
            if (edits.Any())
            {
                WriteJsonDictionary(path, edits, keyToSortOrder, EditsFileNoteToTranslatorComment);
            }
            else
            {
                File.Delete(path);
            }
        }

        protected virtual void SaveNewLanguageTemplate(Dictionary<string, TranslationEdit> edits, Func<string, string> keyToSortOrder)
        {
            string path = GetPathToNewLanguageTemplate();
            if (edits.Any())
            {
                WriteJsonDictionary(path, edits, keyToSortOrder, TemplateComment);
            }
            else
            {
                File.Delete(path);
            }
        }

        protected virtual Dictionary<string, TranslationEdit> ReadEditsFile(string locale)
        {
            string path = this.GetPathToEditsFile(locale);
            if (File.Exists(path))
            {
                return JsonSerializer.Deserialize<Dictionary<string, TranslationEdit>>(File.ReadAllText(this.GetPathToEditsFile(locale)), GetJsonReaderOptions())
                    ?? throw new JsonException($"File should not contain just null: '{this.GetPathToEditsFile(locale)}'");
            }
            else
            {
                return new();
            }
        }

        public override bool GenerateI18nFiles(bool verifyOnly, IReadOnlyCollection<DiscoveredString> discoveredStrings)
        {
            this.anyErrorsReported = false;

            // Note that discoveredStrings might contain the same string twice, discovered at different points in the code.
            //  We're only going to look at one of them.
            Dictionary<string, DiscoveredString> foundStringMap = new();
            foreach (var discoveredString in discoveredStrings)
            {
                string sdvFormatString = discoveredString.isFormat ? SdvTranslator.TransformCSharpFormatStringToSdvFormatString(discoveredString.localizedString) : discoveredString.localizedString;
                foundStringMap[sdvFormatString] = discoveredString;
            }

            Dictionary<string, string>? oldKeyToStringDict = ReadTranslationTable(locale: null);
            Dictionary<string, string> oldStringToKeyDict = this.ReverseDefaultJsonDict(oldKeyToStringDict);

            var newStrings = foundStringMap.Keys.Where(s => !oldStringToKeyDict.ContainsKey(s)).ToList();
            var deletedStrings = oldStringToKeyDict.Keys.Where(s => !foundStringMap.ContainsKey(s)).ToList();

            var matchedStringChanges = this.TryMakeMatches(newStrings, deletedStrings);
            Dictionary<string, string> newStringToKeyDict = buildSourceLanguageStringToKeyDict(oldStringToKeyDict, matchedStringChanges);
            var newDefaultJson = newStringToKeyDict.ToDictionary(p => p.Value, p => p.Key);

            var keySortOrderFunction = this.GenerateKeySortFunction(newDefaultJson, foundStringMap);

            if (newStrings.Any() || deletedStrings.Any())
            {
                if (verifyOnly)
                {
                    this.Error(TranslationRequired, "Localized strings have been changed - rebuild locally and commit any localization changes.");
                    return false;
                }
                else
                {
                    this.SaveTranslationTable(null, newDefaultJson, keySortOrderFunction);

                    var templateDictionary = new Dictionary<string, TranslationEdit>();
                    foreach (var pair in foundStringMap)
                    {
                        string sourceLanguageString = pair.Key;
                        var discoveredString = pair.Value;
                        Uri? link = this.config.TryMakeGithubLink(discoveredString.file, discoveredString.line);

                        string key = newStringToKeyDict[sourceLanguageString];
                        templateDictionary.Add(key, new TranslationEdit(null, sourceLanguageString, null, null, link));
                    }

                    this.SaveNewLanguageTemplate(templateDictionary, keySortOrderFunction);
                }
            }

            foreach (string locale in this.GetActiveLocales())
            {
                Dictionary<string, string>? translations;
                try
                {
                    translations = this.ReadTranslationTable(locale);
                }
                catch (Exception ex)
                {
                    this.Error(LocaleJsonUnusable, $"Translation file for '{locale}', is unreadable: {ex.Message}");
                    continue;
                }

                Dictionary<string, TranslationEdit> edits;
                try
                {
                    edits = this.ReadEditsFile(locale);
                }
                catch (Exception ex)
                {
                    this.Error(LocaleEditsJsonUnusable, $"The translation edits file for '{locale}', is unreadable: {ex.Message}");
                    continue;
                }

                if (verifyOnly && edits.Any(e => e.Value.newTarget is not null))
                {
                    this.Error(TranslationRequired, $"The translation edits file for '{locale}' contains new translations that have not been applied.  Run the build locally and commit the resulting changes and resubmit the build.");
                    return false;
                }

                // Apply any new translations that are still valid
                var appliedEditKeys = new HashSet<string>();
                foreach (var edit in edits)
                {
                    if (edit.Value.newTarget is not null && newDefaultJson.TryGetValue(edit.Key, out string? currentSource) && edit.Value.newSource == currentSource)
                    {
                        translations[edit.Key] = edit.Value.newTarget;
                        appliedEditKeys.Add(edit.Key);
                    }
                }

                // Delete any translations that aren't used anymore
                foreach (var irrelevantKey in translations.Keys.Where(k => !newDefaultJson.ContainsKey(k)).ToArray())
                {
                    translations.Remove(irrelevantKey);
                }

                // Start creating the edits json file.
                var newEdits = new Dictionary<string, TranslationEdit>();
                foreach (var edit in matchedStringChanges)
                {
                    Uri? link = null;
                    if (edit.newString is not null)
                    {
                        var discoveredString = foundStringMap[edit.newString];
                        link = this.config.TryMakeGithubLink(discoveredString.file, discoveredString.line);
                    }


                    if (edit.deletedString is null && edit.newString is not null)
                    {
                        // We added a new thing to translate.
                        newEdits.Add(
                            newStringToKeyDict[edit.newString],
                            new TranslationEdit(oldSource: null, newSource: edit.newString, oldTarget: null, newTarget: null, link: link));
                        // No need to check for an old translation edit, this string is new.
                    }
                    else if (edit.deletedString is not null && edit.newString is not null)
                    {
                        string key = oldStringToKeyDict[edit.deletedString];
                        if (!appliedEditKeys.Contains(key)) // false when the translator changed the source at the same time.
                        {
                            string? oldTranslatedValue;
                            string? oldSource;
                            if (edits.TryGetValue(key, out var oldEdit))
                            {
                                // This is a change to the source where the translation hasn't even caught up to the previous one yet.
                                oldSource = oldEdit.oldSource;
                                oldTranslatedValue = oldEdit.oldTarget;
                            }
                            else
                            {
                                oldSource = oldKeyToStringDict[key];
                                oldTranslatedValue = translations[key];
                                translations.Remove(key);
                            }
                            newEdits.Add(
                                key,
                                new TranslationEdit(oldSource: oldSource, newSource: edit.newString, oldTarget: oldTranslatedValue, newTarget: null, link: link));
                            translations.Remove(key);
                        }
                    }
                }

                // Retain any old edits that are still needed
                foreach (var editPair in edits)
                {
                    if (!newEdits.ContainsKey(editPair.Key) && newDefaultJson.ContainsKey(editPair.Key) && !appliedEditKeys.Contains(editPair.Key))
                    {
                        newEdits.Add(editPair.Key, editPair.Value);
                    }
                }

                foreach (var pair in foundStringMap)
                {
                    string sourceLanguageString = pair.Key;
                    var discoveredString = pair.Value;
                    Uri? link = this.config.TryMakeGithubLink(discoveredString.file, discoveredString.line);

                    string key = newStringToKeyDict[sourceLanguageString];
                    if (!translations.ContainsKey(key) && !newEdits.ContainsKey(key))
                    {
                        newEdits.Add(key, new TranslationEdit(null, sourceLanguageString, null, null, link));
                    }
                }

                if (!verifyOnly)
                {
                    this.SaveTranslationTable(locale, translations, keySortOrderFunction);
                    this.SaveEditsFile(locale, newEdits, keySortOrderFunction);
                }
            }

            return !this.anyErrorsReported;
        }

        protected virtual JsonSerializerOptions GetJsonReaderOptions() => new()
        {
            ReadCommentHandling = JsonCommentHandling.Skip
        };

        public static void WriteJsonDictionary<TValue>(string path, Dictionary<string, TValue> dictionary, Func<string,string> stringToSortOrder, string? prefix)
        {
            var writeOptions = new JsonSerializerOptions()
            {
                WriteIndented = true,
                Encoder = JavaScriptEncoder.Create(UnicodeRanges.All),
                Converters = { new SortedDictionaryJsonConverter<TValue>(stringToSortOrder) }
            };
            var content = (prefix is null ? "" : prefix + Environment.NewLine) + JsonSerializer.Serialize(dictionary, writeOptions);
            Directory.CreateDirectory(Path.GetDirectoryName(path)!);
            File.WriteAllText(path, content);
        }

        private Func<string,string> GenerateKeySortFunction(Dictionary<string, string> newDefaultJson, Dictionary<string,DiscoveredString> stringToDiscoveredString)
        {
            // newDefaultJson is key->string
            // stringToDiscoveredString is string->DiscoveredString
            // function is key->sortOrder
            return (key) =>
            {
                var sourceLangStr = newDefaultJson[key];
                var discoveredString = stringToDiscoveredString[sourceLangStr];
                return $"{discoveredString.file ?? ""}:{discoveredString.line ?? 0:8d}";
            };
        }

        private Dictionary<string, string> buildSourceLanguageStringToKeyDict(Dictionary<string, string> oldStringToKeyDict, List<(string? newString, string? deletedString)> matchedStringChanges)
        {
            var newStringToKeyDict = new Dictionary<string, string>(oldStringToKeyDict);
            int maxKeyValue = this.GetMaxKey(oldStringToKeyDict.Values);
            foreach (var match in matchedStringChanges)
            {
                if (match.newString is not null)
                {
                    if (match.deletedString is not null)
                    {
                        newStringToKeyDict[match.newString] = newStringToKeyDict[match.deletedString];
                    }
                    else
                    {
                        ++maxKeyValue;
                        string newKey = maxKeyValue.ToString("x6");
                        newStringToKeyDict[match.newString] = newKey;
                    }
                }
                if (match.deletedString is not null)
                {
                    newStringToKeyDict.Remove(match.deletedString);
                }
            }

            return newStringToKeyDict;
        }

        private const int MinimumFuzzyMatchScore = 65;

        private static readonly Regex hexSixPattern = new Regex(@"[0-9a-f]{6}", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);

        private int GetMaxKey(IEnumerable<string> keys)
        {
            int maxKey = 0;
            foreach (var key in keys)
            {
                if (hexSixPattern.IsMatch(key))
                {
                    int value = int.Parse(key, System.Globalization.NumberStyles.HexNumber);
                    if (value > maxKey)
                    {
                        maxKey = value;
                    }
                }
            }
            return maxKey;
        }

        private List<(string? newString, string? deletedString)> TryMakeMatches(List<string> givenNewStrings, List<string> givenDeletedStrings)
        {
            List<(string newString, string deletedString, int score)> matches = new();
            foreach (var newString in givenNewStrings)
            {
                foreach (var deletedString in givenDeletedStrings)
                {
                    var score = Fuzz.TokenSetRatio(newString, deletedString);
                    if (score >= MinimumFuzzyMatchScore)
                    {
                        matches.Add((newString, deletedString, score));
                    }
                }
            }
            matches.Sort((t1, t2) => t2.score.CompareTo(t1.score));

            List<(string? newString, string? deletedString)> result = new();
            var actualNewStrings = new HashSet<string>(givenNewStrings);
            var actualDeletedStrings = new HashSet<string>(givenDeletedStrings);
            while (matches.Any())
            {
                var match = matches.First();
                actualNewStrings.Remove(match.newString);
                actualDeletedStrings.Remove(match.deletedString);
                matches.RemoveAll(t => t.newString == match.newString);
                matches.RemoveAll(t => t.deletedString == match.deletedString);
                result.Add((match.newString, match.deletedString));
            }
            result.AddRange(actualNewStrings.Select(s => ((string?)s, (string?)null)));
            result.AddRange(actualDeletedStrings.Select(s => ((string?)null, (string?)s)));
            return result;
        }

        private Dictionary<string, string> ReverseDefaultJsonDict(Dictionary<string, string> oldKeyToStringDict)
        {
            Dictionary<string, string> result = new();
            foreach (var pair in oldKeyToStringDict)
            {
                if (result.ContainsKey(pair.Key))
                {
                    this.Error(DefaultJsonInvalidUserEdit, $"default.json contains two keys that translate to the same string - discarding {pair.Key} => \"{pair.Value}\"");
                }
                else
                {
                    result[pair.Value] = pair.Key;
                }
            }

            return result;
        }
    }
}
